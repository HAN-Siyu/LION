% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Sequence.R
\name{computeFreq}
\alias{computeFreq}
\title{Computation of the K-Mer Frequencies of RNA or Protein Sequences}
\usage{
computeFreq(
  seqs,
  seqType = c("RNA", "Pro"),
  computePro = c("RPISeq", "DeNovo", "rpiCOOL"),
  k = 3,
  EDP = FALSE,
  normalize = c("none", "row", "column"),
  normData = NULL,
  parallel.cores = 2,
  cl = NULL
)
}
\arguments{
\item{seqs}{sequences loaded by function \code{\link[seqinr]{read.fasta}} from \code{\link[seqinr]{seqinr-package}}. Or a list of RNA/protein sequences.
RNA sequences will be converted into lower case letters, but
protein sequences will be converted into upper case letters.
Each sequence should be a vector of single characters.}

\item{seqType}{a string that specifies the nature of the sequence: \code{"RNA"} or \code{"Pro"} (protein).
If the input is DNA sequence and \code{seqType = "RNA"}, the DNA sequence will be converted to RNA sequence automatically.
Default: \code{"RNA"}.}

\item{computePro}{a string that specifies the computation mode of protein sequences: \code{"RPISeq"}, \code{"DeNovo"},
or \code{"rpiCOOL"}. Ignored when \code{seqType = "RNA"}.
Three modes indicate three different amino acid residues classifications that corresponds to methods "RPISeq", "De Novo prediction",
and "rpiCOOL". See details below. Default: \code{"RPISeq"}.}

\item{k}{an integer that indicates the sliding window step. Default: \code{3}.}

\item{EDP}{logical. If \code{TRUE}, entropy density profile (EDP) will be computed. Default: \code{FALSE}.}

\item{normalize}{can be \code{"none"}, \code{"row"} or \code{"column"}. Indicate if the frequencies should be normalized.
If normalize, should the features be normalized by row (each sequence) or by column (each feature)?
See details below. Default: \code{"none"}.}

\item{normData}{is the normalization data generated by this function.
If the input dataset is training set, or normalize strategy is \code{"none"} or \code{"row"},
just leave \code{normData = NULL}. If users want to build test set and the normalize strategy is \code{"column"},
the normalization data of the corresponding training set generated by this function should be passed to this argument.
See examples.}

\item{parallel.cores}{an integer specifying the number of cores for parallel computation. Default: \code{2}.
Set \code{parallel.cores = -1} to run with all the cores. \code{parallel.cores} should be == -1 or >= 1.}

\item{cl}{parallel cores to be passed to this function.}
}
\value{
If \code{normalize = "none"} or \code{normalize = "row"}, this function will return a data frame.
Row names are sequences names, and column names are polymer names.

If \code{normalize = "column"}, the function will return a list containing features (a data frame named "feature")
and normalization values (a list named "normData") for extracting features for test sets.
}
\description{
This function can calculate the \emph{k}-mer frequencies of RNA or protein sequences.
Three kinds of protein representations are available.
}
\details{
Function \code{computeFreq} calculate the \emph{k}-mer frequencies of RNA/protein sequences. Three computation modes
of protein frequencies are:

\code{RPISeq}:
\{A, G, V\}, \{I, L, F, P\}, \{Y, M, T, S\}, \{H, N, Q, W\}, \{R, K\}, \{D, E\}, \{C\}
(Ref: [3]);

\code{DeNovo}:
\{D, E\}, \{H, R, K\}, \{C, G, N, Q, S, T, Y\}, \{A, F, I, L, M, P, V, W\}
(Ref: [4]).

\code{rpiCOOL}:
\{A, E\}, \{I, L, F, M, V\}, \{N, D, T, S\}, \{G\}, \{P\}, \{R, K, Q, H\}, \{Y, W\}, \{C\}
(Ref: [5]).

If \code{EDP = TRUE}, entropy density profile (EDP) will be computed with equation:
s_\emph{i} = -1/H * c_\emph{i} * log2(c_\emph{i}), H = -sum(c_\emph{j} * log2(c_\emph{j})).
c is the frequencies, \emph{i} and \emph{j} represents the indices of \emph{k}-mer frequencies. (Ref: [6])

The function also provides two normalization strategies: by row (each sequence) or by column (each feature).
If by row, the dataset will be processed with equation (Ref: [2]):
d_\emph{i} = (f_\emph{i} - min\{f_1, f_2, ...\}) / max\{f_1, f_2, ...\}.
f_1, f_2, ..., f_\emph{i} are the original values of each row.

If by column, the dataset will be processed with:
d_\emph{i} = (f_\emph{i} - min\{f_1, f_2, ...\}) / (max\{f_1, f_2, ...\} - min\{_f1, f_2, ...\}).

In [2], normalization is computed by row (each sequence).
}
\section{References}{

[1] Han S, Yang X, Sun H, \emph{et al}.
LION: an integrated R package for effective prediction of ncRNAâ€“protein interaction.
Briefings in Bioinformatics. 2022; 23(6):bbac420

[2] Shen J, Zhang J, Luo X, \emph{et al}.
Predicting protein-protein interactions based only on sequences information.
Proc. Natl. Acad. Sci. U. S. A. 2007; 104:4337-41

[3] Muppirala UK, Honavar VG, Dobbs D.
Predicting RNA-protein interactions using only sequence information.
BMC Bioinformatics 2011; 12:489

[4] Wang Y, Chen X, Liu Z-P, \emph{et al}.
De novo prediction of RNA-protein interactions from sequence information.
Mol. BioSyst. 2013; 9:133-142

[5] Akbaripour-Elahabad M, Zahiri J, Rafeh R, \emph{et al}.
rpiCOOL: A tool for In Silico RNA-protein interaction detection using random forest.
J. Theor. Biol. 2016; 402:1-8

[6] Yang C, Yang L, Zhou M, \emph{et al}.
LncADeep: an ab initio lncRNA identification and functional annotation tool based on deep learning.
Bioinformatics. 2018; 34(22):3825-3834.
}

\examples{

# Use "read.fasta" function of package "seqinr" to read a FASTA file:

seqs1 <- seqinr::read.fasta(file =
"http://www.ncbi.nlm.nih.gov/WebSub/html/help/sample_files/nucleotide-sample.txt")
seqFreq1 <- computeFreq(seqs1, seqType = "RNA", k = 4, normalize = "row",
                        parallel.cores = 2)

data(demoPositiveSeq)
seqs2 <- demoPositiveSeq$Pro.positive

# Training set with normalization on column:

seqFreq2 <- computeFreq(seqs2, seqType = "Pro", computePro = "RPISeq", k = 3,
                        normalize = "column", parallel.cores = 2)

# If build a test set with normalization on column,
# "normData" of the corresponding training set (generated by this function) is required:

seqFreq3 <- computeFreq(seqs2, seqType = "Pro", computePro = "RPISeq", k = 3,
                        normalize = "column", normData = seqFreq2$normData,
                        parallel.cores = 2)

# If no normalization used:

seqFreq4 <- computeFreq(seqs2, seqType = "Pro", computePro = "DeNovo", k = 3,
                        normalize = "none", parallel.cores = 2)

}
\seealso{
\code{\link{featureFreq}}
}
